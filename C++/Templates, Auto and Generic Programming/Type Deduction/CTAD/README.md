## [C++ Class Template Argument Deduction - History, Uses, & Enabling it for Classes - Marshall Clow - CppCon 2022](https://www.youtube.com/watch?v=EPfPMW-rOtc&list=LL6MKUgGZ9Q8c2Ff7GnoRoqA)
### Topics covered:
* What is Class Template Argument Deduction?
  * The next step in "let the compiler figure it out".
  * Default Template Arguments in C++03.
  * "Template Argumemt Deduction" also in C++03.
  * auto in C++11.
  * CTAD in C++17.
* What does CTAD do?
  * It fills in missing template arguments.
  * Making `make_XXX` (mostly) redundant. For example, `auto p = std::make_pair(1, 23L);` becomes `std::pair{1, 23L};`
* How does CTAD work?
  * It works through Deduction Guides, a new feature in C++17. There are implicit deduction guides (generated by the compiler) and explicit deduction guidelines (written by a developer).
  * Example: Constructors for std::vector. It only has one explicit deduction guide (due to the compiler not knowing about iterators).
  * Deduction guides for your classes.
  * Writing deduction guides for containers: Existential Questions. What is an iterator? What is an allocator? Integral types ar neither allocators nor iterators.
  * Pitfalls of writting your own deduction guides.
* Testing and Debugging.
* Post C++17 Work
  * CTAD for alias templates (C++20). Example: Given `template <typename T> myVec = std::vector<T>;`, the following works fine: `myVec v(first, last);`.
  * CTAD for aggregates (C++20). Example: Given `template <typename T> struct Pt { T x; T y;};`, the following works fine: `Pt p(4L, 3L);`, deducing `Pt<long>`.
  * CTAD for inherited constructors (C++23).

## [C++ Insights - Episode 33: C++17's Class Template Argument Deduction](https://www.youtube.com/watch?v=CU--ILJfriM&list=LL6MKUgGZ9Q8c2Ff7GnoRoqA)

## [Class Template Argument Deduction for Everyone - Stephan T. Lavavej - CppCon 2018](https://www.youtube.com/watch?v=-H-ut6j1BYU&list=LL6MKUgGZ9Q8c2Ff7GnoRoqA)


